[
  {
    "id": "1000",
    "name": "A+B",
    "extension": "py",
    "filename": "1000_A+B.py",
    "path": "1000-1199/1000_A+B.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1000",
    "tags": [
      "matematicas",
      "facil"
    ],
    "content": {
      "description": "Un ejemplo de inicio, literalmente el Hola Mundo de la programación competitiva.",
      "steps": "1. Recibir los valores de `A` y `B`\r\n 2. Mostrar la suma de `A` y `B`",
      "code": "```python\nA, B = map(int, input().split())\r\nprint(A + B)\n```"
    }
  },
  {
    "id": "1001",
    "name": "Material",
    "extension": "py",
    "filename": "1001_Material.py",
    "path": "1000-1199/1001_Material.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1001",
    "tags": [
      "facil",
      "bucles"
    ],
    "content": {
      "description": "Leer y mostrar datos de entrada y nada más.",
      "steps": "1. Obtener la cantidad de números `N`\r\n 2. Leer el i-ésimo número\r\n 3. Mostrar el i-ésimo número",
      "code": "```python\nN = int(input())\r\nfor i in range(N):\r\n    print(int(input()))\n```"
    }
  },
  {
    "id": "1003",
    "name": "Rumores",
    "extension": "py",
    "filename": "1003_Rumores.py",
    "path": "1000-1199/1003_Rumores.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1003",
    "tags": [
      "grafos",
      "busqueda",
      "recorrido",
      "medio"
    ],
    "content": {
      "description": "> [!alert] ¡Atención\r\n > Existe un problema con el Juez en línea, por lo que no se puede verificar la solución.\r\n > Sin embargo, el código es correcto, puede verificarse traduciendo el código a otro lenguaje.\r\n\r\n Para este problema, se utiliza el concepto de grafos como listas de adyacencia para\r\n determinar si una persona puede llegar a otra, en simples palabras es verificar\r\n si el elemento `graph[X]` contiene a `Y` o algún amigo de `Y`.",
      "steps": "1. Obtener el número de casos de prueba `T`\r\n 2. Por cada caso, obtener el número de personas `N` y el número de relaciones `M`\r\n 3. Utilizando un grafo, obtener las relaciones entre las personas `a --> b`\r\n 4. Obtener las personas `X` e `Y`\r\n 5. Mediante un recorrido del grafo, verificar si `X` puede llegar a `Y`\r\n 6. Imprimir `\"SI\"` si puede llegar, `\"NO\"` en caso contrario",
      "code": "```python\ndef verify(graph, X, Y):\r\n    visited = [False for _ in range(len(graph) + 1)]\r\n    queue = [X]\r\n    visited[X] = True\r\n\r\n    while queue:\r\n        node = queue.pop(0)\r\n        for friend in graph[node]:\r\n            if not visited[friend]:\r\n                queue.append(friend)\r\n                visited[friend] = True\r\n    return visited[Y]\r\n\r\n\r\nT = int(input())\r\nfor i in range(T):\r\n    N, M = map(int, input().split())\r\n    relations = [[] for _ in range(N + 1)]\r\n    for j in range(M):\r\n        u, v = map(int, input().split())\r\n        relations[u].append(v)\r\n    X, Y = map(int, input().split())\r\n    result = verify(relations, X, Y)\r\n    if result:\r\n        print(\"SI\")\r\n    else:\r\n        print(\"NO\")\n```"
    }
  },
  {
    "id": "1004",
    "name": "Saliendo del laberinto",
    "extension": "py",
    "filename": "1004_Saliendo_del_laberinto.py",
    "path": "1000-1199/1004_Saliendo_del_laberinto.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1004",
    "tags": [
      "listas",
      "medio",
      "matrices"
    ],
    "content": {
      "description": "TODO: Revisar la descripción del problema",
      "steps": "1. Recibir el número de casos de prueba `T`\r\n 2. Recibir el tamaño de la matriz `N` y `M`\r\n 3. Recibir `N` lineas con `M` caracteres que representan la matriz\r\n 4. Recibir las coordenadas de `X1` y `Y1` de pepito\r\n 5. Recibir las coordenadas de `X2` y `Y2` de la salida",
      "code": "```python\nT = int(input())\r\nway = \".\"\r\nwall = \"#\"\r\nfor _ in range(T):\r\n    N, M = map(int, input().split())\r\n    matrix = [[char for char in input()] for _ in range(N)]\r\n    X1, Y1 = map(int, input().split())\r\n    X2, Y2 = map(int, input().split())\n```"
    }
  },
  {
    "id": "1005",
    "name": "Bob el jardinero",
    "extension": "py",
    "filename": "1005_Bob_el_jardinero.py",
    "path": "1000-1199/1005_Bob_el_jardinero.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1005",
    "tags": [
      "facil",
      "matematicas",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "> [!important] Incompleto\r\n > La solución está incompleta, se necesita mostrar dos decimales, no redondear a dos decimales",
      "steps": "1. Obtener el número de casos de prueba `T`\r\n 2. Recibir un string para cada caso de prueba\r\n 3. Contar las vocales en cada string\r\n 4. Calcular el porcentaje de cada vocal `(vocal * 100 / total)`",
      "code": "```python\nT = int(input())\r\nfor k in range(1, T + 1):\r\n    text = input()\r\n    total = len(text)\r\n    a, e, i, o, u = 0, 0, 0, 0, 0\r\n    for char in text:\r\n        if char == \"a\":\r\n            a += 1\r\n        elif char == \"e\":\r\n            e += 1\r\n        elif char == \"i\":\r\n            i += 1\r\n        elif char == \"o\":\r\n            o += 1\r\n        elif char == \"u\":\r\n            u += 1\r\n\r\n    print(f\"Caso {k}:\")\r\n    print(f\"a= {(a * 100 / total, 2):.2f}\")\r\n    print(f\"e= {(e * 100 / total, 2):.2f}\")\r\n    print(f\"i= {(i * 100 / total, 2):.2f}\")\r\n    print(f\"o= {(o * 100 / total, 2):.2f}\")\r\n    print(f\"u= {(u * 100 / total, 2):.2f}\")\n```"
    }
  },
  {
    "id": "1006",
    "name": "Cadena Bailarina",
    "extension": "py",
    "filename": "1006_Cadena_Bailarina.py",
    "path": "1000-1199/1006_Cadena_Bailarina.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1006",
    "tags": [
      "facil",
      "cadenas",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "> [!warning] Descripción del problema\r\n > Si es una oración, se debe considerar los espacios. Es decir, saltar a la siguiente letra si es un espacio\r\n\r\n Para este caso se puede utilizar código ASCII para cambiar de mayúscula a minúscula y viceversa, pero para Python se puede utilizar `str.upper()` y `str.lower()`",
      "steps": "1. Obtener el número de casos de prueba `T`\r\n 2. Por cada caso, recibir un string\r\n 3. Iterar por cada letra del string\r\n 4. Cambiar la secuencia por MAYÚSCULA - minúscula - MAYÚSCULA - minúscula ...",
      "code": "```python\nT = int(input())\r\nfor _ in range(T):\r\n    text = input()\r\n    result = \"\"\r\n    upper = True\r\n    for char in text:\r\n        if char == \" \":\r\n            result += \" \"\r\n            continue\r\n        if upper:\r\n            result += char.upper()\r\n            upper = False\r\n        else:\r\n            result += char.lower()\r\n            upper = True\r\n    print(result)\n```"
    }
  },
  {
    "id": "1007",
    "name": "Pipo el payaso",
    "extension": "py",
    "filename": "1007_Pipo_el_payaso.py",
    "path": "1000-1199/1007_Pipo_el_payaso.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1007",
    "tags": [
      "cadenas",
      "bucles",
      "condicionaless",
      "medio"
    ],
    "content": {
      "description": "> [!note] Nota\r\n > La variable `winner` solo cambia cuando `letter_count` es mayor a `max_words`,\r\n > por lo que si hay un empate, el ganador será el que se haya registrado primero",
      "steps": "1. Obtener el número de casos de prueba `T`\r\n 2. Por cada caso, recibir el número de participantes `N`\r\n 3. Por cada participante, recibir un string (trabalenguas)\r\n 4. Convertir el string en una lista de palabras con `.split()`\r\n 5. Contar la cantidad de palabras que comienzan con la misma letra\r\n 6. Obtener el máximo de palabras que comienzan con la misma letra",
      "code": "```python\ndef max_prefix(words):\r\n    \"\"\"\r\n    La función recibe una LISTA de palabras, crea un diccionario con la cantidad de palabras que comienzan con la misma letra y retorna el máximo valor de palabras que comienzan con la misma letra\r\n    \"\"\"\r\n    prefix = {}\r\n    for word in words:\r\n        if word[0] in prefix:\r\n            prefix[word[0]] += 1\r\n        else:\r\n            prefix[word[0]] = 1\r\n    return max(prefix.values())\r\n\r\n\r\nT = int(input())\r\nfor i in range(T):\r\n    N = int(input())\r\n\r\n    # Por defecto el ganador es el primer participante\r\n    winner = 1\r\n    max_words = 0\r\n\r\n    for j in range(N):\r\n        text = input()\r\n        words = text.split()\r\n        prefix_count = max_prefix(words)\r\n        if prefix_count > max_words:\r\n            max_words = prefix_count\r\n            winner = j + 1\r\n    print(f\"El ganador es {winner}\")\n```"
    }
  },
  {
    "id": "1008",
    "name": "Ordenando mi directorio",
    "extension": "py",
    "filename": "1008_Ordenando_mi_directorio.py",
    "path": "1000-1199/1008_Ordenando_mi_directorio.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1008",
    "tags": [
      "busqueda",
      "ordenamiento",
      "listas",
      "cadenas",
      "bucles",
      "facil"
    ],
    "content": {
      "description": "El problema consiste en busqueda y ordenamiento de elementos en una lista de archivos,\r\n donde es solo hay que buscar los elementos \".\" y \"..\" y colocarlos al final de la lista.\r\n\r\n > [!note] Nota\r\n > Al intercambiar el elemento \".\" o \"..\" con el último elemento de la lista,\r\n > se debe decrementar el índice del último elemento de la lista para no volver\r\n > a intercambiar el mismo elemento.",
      "steps": "1. Obtener los casos de prueba `T``\r\n 2. Por cada caso de prueba obtener el número de archivos `N`\r\n 3. Por cada caso de prueba leer y guardar los nombres de los archivos\r\n 4. Buscar \".\" o \"..\" en la lista de archivos\r\n 5. Verificar si \".\" y \"..\" son los últimos elementos de la lista (en cualquier orden)\r\n     - Si es así mostrar \"Caso [i]\" y listar los archivos\r\n     - Si no, buscar \".\" o \"..\" e intercambiarlos con el último elemento de la lista\r\n     - Repetir el paso 5, pero ahora con el penúltimo elemento de la lista",
      "code": "```python\ndef verifyFiles(fileList):\r\n    if fileList[-1] == \".\" and fileList[-2] == \"..\":\r\n        return True\r\n    elif fileList[-1] == \"..\" and fileList[-2] == \".\":\r\n        return True\r\n    else:\r\n        return False\r\n\r\n\r\ndef findDotsIndex(fileList):\r\n    for i in range(len(fileList)):\r\n        if fileList[i] == \".\" or fileList[i] == \"..\":\r\n            return i\r\n    return -1\r\n\r\n\r\ndef swapFiles(fileList, index_a, index_b):\r\n    temp = fileList[index_a]\r\n    fileList[index_a] = fileList[index_b]\r\n    fileList[index_b] = temp\r\n\r\n\r\nT = int(input())\r\nfor i in range(T):\r\n    N = int(input())\r\n    files_list = []\r\n    for j in range(N):\r\n        file = input()\r\n        files_list.append(file)\r\n\r\n    last_index = len(files_list) - 1\r\n    while not verifyFiles(files_list):\r\n        dot_index = findDotsIndex(files_list)\r\n        swapFiles(files_list, dot_index, last_index)\r\n        last_index -= 1\r\n\r\n    print(f\"Caso {i + 1}:\")\r\n    for file in files_list:\r\n        print(file)\r\n    print()\n```"
    }
  },
  {
    "id": "1009",
    "name": "Mi musica  Favorita",
    "extension": "py",
    "filename": "1009_Mi_musica _Favorita.py",
    "path": "1000-1199/1009_Mi_musica _Favorita.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1009",
    "tags": [
      "matematicas",
      "listas",
      "medio"
    ],
    "content": {
      "description": "El problema se trata de la obtención de subconjuntos de una lista que representan la duración de las canciones de una lista de reproducción. El objetivo es obtener el subconjunto de canciones que sumen la mayor cantidad de tiempo posible, pero que no sobrepasen el tiempo máximo de reproducción del casete.\r\n\r\n !TODO: Utilizar operadores binarios",
      "steps": "1. Obtener el número de casos de prueba `TC`\r\n 2. Por cada caso de prueba, obtener el siguiente string \"N T ...T_i\"\r\n     - `N`: Minutos soportados por el casete\r\n     - `T`: Número de canciones en la lista\r\n     - `T_i`: Duración de la i-ésima canción (se maneja como time_list)\r\n 3. Obtener el número máximo de canciones que entran en `N` minutos\r\n 4. Imprimir el resultado con espacios",
      "code": "```python\ndef get_max_songs(N, time_list):\r\n    pass\r\n\r\n\r\nTC = int(input())\r\nfor i in range(TC):\r\n    # * time_list es el resto de la lista de tiempos\r\n    N, T, *times_list = input().split()\r\n    result = get_max_songs(N, times_list)\r\n    # Imprimir el resultado con espacios\r\n    print(result.join(\" \"))\n```"
    }
  },
  {
    "id": "1010",
    "name": "UMSA WORD",
    "extension": "py",
    "filename": "1010_UMSA_WORD.py",
    "path": "1000-1199/1010_UMSA_WORD.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1010",
    "tags": [
      "cadenas",
      "hashmap",
      "busqueda",
      "bucles",
      "condicionales",
      "medio"
    ],
    "content": {
      "description": "Dado la variable `word` que contiene una cadena sin espacios de la palabra\r\n a buscar, para el caso es `\"UMSAICPC\"`.\r\n\r\n > [!check] Solución aceptada\r\n > La solución es para casos genéricos, no solo para la palabra \"UMSAICPC\"",
      "steps": "1. Obtener el número de casos de prueba `N`\r\n 2. Por cada caso, obtener la cadena de caracteres\r\n 3. Obtener un diccionario de la cantidad de caracteres de la cadena\r\n 4. De la cadena de la palabra a buscar, verificar si la cantidad de caracteres de la cadena de entrada es mayor o igual a la cantidad de caracteres de la palabra a buscar\r\n 5. Si es así, imprimir \"ES POSIBLE\", caso contrario \"NO ES POSIBLE\"",
      "code": "```python\ndef count_chars(word):\r\n    result = dict()  # Alternamente se puede usar {}\r\n    for char in word:\r\n        if char in result:\r\n            result[char] += 1\r\n        else:\r\n            result[char] = 1\r\n    return result\r\n\r\n\r\nword = \"UMSAICPC\"\r\nchars_word = count_chars(word)\r\n\r\nN = int(input())\r\nfor i in range(N):\r\n    input_text = input()\r\n    chars_input = count_chars(input_text)\r\n    is_possible = True\r\n    for char in chars_word:\r\n        if char not in chars_input:\r\n            is_possible = False\r\n            break\r\n        if chars_word[char] >= chars_input[char]:\r\n            is_possible = False\r\n            break\r\n\r\n    if is_possible:\r\n        print(\"ES POSIBLE\")\r\n    else:\r\n        print(\"NO ES POSIBLE\")\n```"
    }
  },
  {
    "id": "1011",
    "name": "Futbol",
    "extension": "py",
    "filename": "1011_Futbol.py",
    "path": "1000-1199/1011_Futbol.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1011",
    "tags": [
      "matematicas",
      "bucles",
      "facil"
    ],
    "content": {
      "description": "Para este caso es necesario utilizar la fórmula de la distancia\r\n entre dos puntos en un plano cartesiano.\r\n\r\n $$\r\n d = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\r\n $$",
      "steps": "1. Recibir el número (`N`) de jugadores del equipo\r\n 2. Por cada jugador, recibir las coordenadas `x`, `y`\r\n 3. Recibir el número de consultas `Q`\r\n 4. Por cada consulta, recibir los jugadores a operar\r\n 5. Calcular la distancia entre los jugadores",
      "code": "```python\nN = int(input())\r\n\r\n# Cada jugador tiene una tupla (x, y)\r\n# ! Se comienza desde el 1 (porque los jugadores son de 1 a N)\r\nplayers = [(0, 0)] * (N + 1)\r\nfor i in range(N):\r\n    x, y = map(int, input().split())\r\n    players[i + 1] = (x, y)\r\n\r\nQ = int(input())\r\n\r\nfor i in range(Q):\r\n    p1, p2 = map(int, input().split())\r\n    distance = (\r\n        (players[p1][0] - players[p2][0]) ** 2 + (players[p1][1] - players[p2][1]) ** 2\r\n    ) ** 0.5\r\n    print(f\"{distance:.2f}\")\n```"
    }
  },
  {
    "id": "1014",
    "name": "Marisol la exploradora",
    "extension": "py",
    "filename": "1014_Marisol_la_exploradora.py",
    "path": "1000-1199/1014_Marisol_la_exploradora.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1014",
    "tags": [
      "grafos",
      "recorrido",
      "bucles",
      "condicionales",
      "dificil"
    ],
    "content": {
      "description": "TODO: Mejorar la complejidad de memoria y tiempo, Realizarlo con kosaraju",
      "steps": "1. Recibir los enteros `N` y `M` hasta una condición de parada\r\n 2. Verficar si `N` y `M` son diferentes a 0 (si lo es terminar de leer datos)\r\n 3. Recibir `M` lineas, dos enteros `X`, `Y` que representa que desde el lugar `X` se puede llegar a `Y`\r\n 4. Guardar el valor de `Y` en una lista de adyacencia de `X`\r\n 5. Recorrer el grafo mediante bfs desde cualquier nodo (para el caso desde el nodo 0)\r\n 6. Si todos los nodos fueron visitados imprimir \"SI\" en caso contrario \"NO\"\r\n 7. Verificar que desde cualquier nodo se pueda llegar a todos los nodos",
      "code": "```python\nimport sys\r\nfrom queue import Queue\r\n\r\n\r\ndef bfs(grafo, nodo=0):\r\n    visitados = [False] * len(grafo)\r\n    q = Queue()\r\n    q.put(nodo)\r\n    visitados[nodo] = True\r\n\r\n    while not q.empty():\r\n        nodo = q.get()\r\n        for adyacente in grafo[nodo]:\r\n            if not visitados[adyacente]:\r\n                q.put(adyacente)\r\n                visitados[adyacente] = True\r\n\r\n    # Verificar si todos en la lista de visitados son True\r\n    return all(visitados)\r\n\r\n\r\nfor line in sys.stdin:\r\n    N, M = map(int, line.split())\r\n    if N == 0 and M == 0:\r\n        break\r\n\r\n    relaciones = [[] for _ in range(N)]\r\n    for i in range(M):\r\n        X, Y = map(int, input().split())\r\n        # Se lo guarda con X-1 y Y-1 para normalizar los indices\r\n        # ya que en el problema se empieza a contar desde 1\r\n        # y en python se empieza a contar desde 0\r\n        relaciones[X - 1].append(Y - 1)\r\n\r\n    results = [bfs(relaciones, i) for i in range(N)]\r\n    if all(results):\r\n        print(\"SI\")\r\n    else:\r\n        print(\"NO\")\n```"
    }
  },
  {
    "id": "1015",
    "name": "StarCraft",
    "extension": "py",
    "filename": "1015_StarCraft.py",
    "path": "1000-1199/1015_StarCraft.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1015",
    "tags": [
      "matematicas",
      "bucles",
      "condicionales",
      "facil"
    ],
    "content": {
      "description": "Para este problema únicamente es utilizar la fórmula de la distancia\r\n entre dos puntosen un plano cartesiano.\r\n\r\n $$\r\n distancia = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}\r\n $$\r\n\r\n con esta distancia, verificamos si está dentro del radio de la bomba.",
      "steps": "1. Recibir los casos de prueba `T`\r\n 2. Por cada caso de prueba, recibir un entero `N` que es la cantidad de coordenadas\r\n 3. Recibir `N` lineas, dos enteros `x`, `y` que representan las coordenadas de una estructura\r\n 4. Recibir la coordenadas `x`, `y` donde cae la bomba y el radio `r` que cubre la bomba\r\n 5. Calcular la distancia entre la coordenada de la bomba y cada una de las coordenadas de las estructuras\r\n 6. Verificar si la distancia es menor o igual al radio de la bomba",
      "code": "```python\ndef distance(coord1, coord2):\r\n    x1, y1 = coord1\r\n    x2, y2 = coord2\r\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\r\n\r\n\r\nT = int(input())\r\nfor i in range(T):\r\n    N = int(input())\r\n    structures = []\r\n    for j in range(N):\r\n        x, y = map(int, input().split())\r\n        structures.append((x, y))\r\n\r\n    X, Y, r = map(int, input().split())\r\n    coord_bomb = (X, Y)\r\n\r\n    affected = 0\r\n    for structure_coord in structures:\r\n        if distance(coord_bomb, structure_coord) <= r:\r\n            affected += 1\r\n\r\n    print(affected)\n```"
    }
  },
  {
    "id": "1017",
    "name": "Cambio de Base",
    "extension": "py",
    "filename": "1017_Cambio_de_Base.py",
    "path": "1000-1199/1017_Cambio_de_Base.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1017",
    "tags": [
      "matematicas",
      "facil",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "Para este problema es necesario conocer el concepto de cambio de base. Este\r\n proceso se logra mediante la división sucesiva del número original entre la base\r\n a la que se quiere cambiar. El residuo de cada división se convierte en un dígito\r\n del nuevo número en la base deseada. El proceso se repite hasta que el número\r\n original sea menor que la base.\r\n\r\n ![ejemplo](https://rea.ceibal.edu.uy/elp/unidad-a-que-hora/cambio_base3.gif)\r\n\r\n > [!note] Nota\r\n > En el código, se pone un limite en el for desde 2 hasta 10 en la iteración,\r\n > ya que el problema indica que el número `n` es igual a `a` en alguna base\r\n > entre 2 y 9.",
      "steps": "1. Recibir el número de casos de prueba `N`\r\n 2. Por cada caso, recibir los números `n` y `a`\r\n 3. Cambiar de base al número n desde 2 hasta 9\r\n 4. Si el número en la nueva base es igual a `a`, imprimir la base (`i`)",
      "code": "```python\ndef change_base(n, base):\r\n    new_n = 0\r\n    exponent = 0\r\n    while n > 0:\r\n        digit = n % base\r\n        new_n += digit * (10**exponent)\r\n        exponent += 1\r\n        n = n // base\r\n\r\n    return new_n\r\n\r\n\r\nN = int(input())\r\nfor _ in range(N):\r\n    n, a = map(int, input().split())\r\n    # i = 2; i < 10; i++\r\n    for i in range(2, 10, 1):\r\n        new_n = change_base(n, i)\r\n        if new_n == a:\r\n            print(i)\r\n            break\n```"
    }
  },
  {
    "id": "1018",
    "name": "Operadores Relacionales",
    "extension": "py",
    "filename": "1018_Operadores_Relacionales.py",
    "path": "1000-1199/1018_Operadores_Relacionales.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1018",
    "tags": [
      "facil",
      "matematicas",
      "condicionales",
      "bucles"
    ],
    "content": {
      "description": "Un vista sencilla a los operadores relacionales `<`, `>`, `=`",
      "steps": "1. Recibir el número de casos de prueba `t`\r\n 2. Por cada caso, recibir los números `a` y `b`\r\n 3. Comparar `a` y `b`, imprimir su relación respectivas",
      "code": "```python\nt = int(input())\r\nfor _ in range(t):\r\n    a, b = map(int, input().split())\r\n    if a < b:\r\n        print(\"<\")\r\n    elif a > b:\r\n        print(\">\")\r\n    else:\r\n        print(\"=\")\n```"
    }
  },
  {
    "id": "1019",
    "name": "Reduciendo Costos",
    "extension": "py",
    "filename": "1019_Reduciendo_Costos.py",
    "path": "1000-1199/1019_Reduciendo_Costos.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1019",
    "tags": [
      "facil",
      "matematicas",
      "condicionales"
    ],
    "content": {
      "description": "Este problema es muy simple, pues hay que obtener el valor\r\n medio de entre tres números, pero para hacerlo de forma\r\n más sencilla se utiliza una lista.",
      "steps": "1. Recibir el número de casos de prueba `T`\r\n 2. Por cada caso, recibir los números `a`, `b` y `c` en la lista `salaries`\r\n 3. Obtener el valor medio de la lista",
      "code": "```python\nT = int(input())\r\nfor i in range(T):\r\n    salaries = list(map(int, input().split()))\r\n    salaries.sort()\r\n    print(f\"Case {i+1}: {salaries[1]}\")\n```"
    }
  },
  {
    "id": "1020",
    "name": "Planificando un viaje",
    "extension": "py",
    "filename": "1020_Planificando_un_viaje.py",
    "path": "1000-1199/1020_Planificando_un_viaje.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1020",
    "tags": [
      "facil",
      "listas",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "> [!note] Nota\r\n > Muy aparte de la difucultad para ingresar datos,\r\n > resaltar que el problema se basa en saber la cantidad de camas\r\n > disponibles en un hotel y su precio, para saber si es posible\r\n > alojar a todos los participantes.",
      "steps": "1. Recibir los casos de prueba hasta que ya no haya datos\r\n 2. Recibir una linea con los siguientes datos:\r\n     - `N`: número de participantes\r\n     - `P`: presupuesto\r\n     - `H`: número de hoteles\r\n     - `S`: número de semanas\r\n 3. Por cada hotel, recibir dos lineas\r\n     - `p`: precio por persona\r\n     - `camas`: linea de camas disponibles por semana (`S` datos)\r\n 4. Verificar si hay camas disponibles para todos los participantes\r\n 5. Si hay camas disponibles, calcular el precio total si esta dentro del presupuesto\r\n 6. Si hay precios válidos, imprimir el menor precio, sino, imprimir \"quedarse en casa\"",
      "code": "```python\nimport sys\r\n\r\nfor line in sys.stdin:\r\n    if line == \"\\n\":\r\n        break\r\n\r\n    N, P, H, S = map(int, line.split())\r\n    prices = []\r\n    for i in range(H):\r\n        p = int(input())\r\n        camas = list(map(int, input().split()))\r\n        # Retorna True si hay un valor mayor o igual a N\r\n        any_camas = any([c >= N for c in camas])\r\n        if any_camas and p * N <= P:\r\n            prices.append(p * N)\r\n\r\n    if prices:\r\n        print(min(prices))\r\n    else:\r\n        print(\"quedarse en casa\")\n```"
    }
  },
  {
    "id": "1021",
    "name": "Lowest Common Ancestor",
    "extension": "py",
    "filename": "1021_Lowest_Common_Ancestor.py",
    "path": "1000-1199/1021_Lowest_Common_Ancestor.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1021",
    "tags": [
      "grafos",
      "arboles",
      "recorrido",
      "medio",
      "bucles",
      "condicionales",
      "matematicas"
    ],
    "content": {
      "description": "Para este caso es necesario generar un árbol binario basado en lo siguiente:\r\n\r\n - La raíz del árbol es el nodo 1\r\n - Para cualquier nodo `x`, su hijo izquierdo es `2 * x` y su hijo derecho es `2 * x + 1`\r\n\r\n TODO: Agregar un ejemplo del árbol generado\r\n\r\n La solución es más matemática que nada, pues por la naturaleza del árbol,\r\n se puede obtener el nodo padre de cualquier nodo `x` con la fórmula `x // 2`.\r\n La idea es obtener los padres de ambos hasta que ambos tengan el mismo padre.",
      "steps": "1. Recibir datos indefinidamente hasta que se reciba una línea en blanco\r\n 2. Por cada linea, se recibe dos números `v` y `w` que representan dos nodos del árbol\r\n 3. Obtener el nivel de los nodos `v` y `w` en el árbol\r\n 4. Mover el nodo de mayor nivel hacia arriba hasta que ambos nodos tengan el mismo nivel\r\n 5. Mover ambos nodos hacia arriba hasta que ambos nodos tengan el mismo padre\r\n 6. Imprimir el nodo padre común más bajo",
      "code": "```python\nimport sys\r\n\r\n\r\ndef get_father(v):\r\n    return v // 2\r\n\r\n\r\ndef get_level(a, b):\r\n    level_a = 0\r\n    level_b = 0\r\n    while a != 1 or b != 1:\r\n        if a != 1:\r\n            a = get_father(a)\r\n            level_a += 1\r\n        if b != 1:\r\n            b = get_father(b)\r\n            level_b += 1\r\n    return level_a, level_b\r\n\r\n\r\nfor line in sys.stdin:\r\n    if line == \"\\n\":\r\n        break\r\n\r\n    v, w = map(int, line.split())\r\n    level_v, level_w = get_level(v, w)\r\n\r\n    while level_v > level_w:\r\n        v = get_father(v)\r\n        level_v -= 1\r\n\r\n    while level_w > level_v:\r\n        w = get_father(w)\r\n        level_w -= 1\r\n\r\n    while v != w:\r\n        v = get_father(v)\r\n        w = get_father(w)\r\n\r\n    print(v)\n```"
    }
  },
  {
    "id": "1022",
    "name": "Mercado Magico",
    "extension": "py",
    "filename": "1022_Mercado_Magico.py",
    "path": "1000-1199/1022_Mercado_Magico.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1022",
    "tags": [
      "medio",
      "listas",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "TODO: Mejorar la complejidad de tiempo, sacrificar memoria por tiempo",
      "steps": "1. Recibir el número de casos de prueba `T`\r\n 2. Por cada caso, recibir el número de productos `N` y el número de consultas `Q`\r\n 3. Recibir la lista de precios de los productos, en total son `N` precios\r\n 4. Por cada consulta, recibir una de las siguientes opciones:\r\n     - `A i v`, implica cambiar el precio del producto `i` a `v`\r\n     - `P i j`, implica sumar el precio de los productos `i` a `j`\r\n 5. Mostrar la suma de los precios de los productos `i` a `j`",
      "code": "```python\nfrom sys import stdin, stdout\r\n\r\nT = int(input())\r\nfor _ in range(T):\r\n    N, Q = map(int, stdin.readline().split())\r\n    prices = list(map(int, stdin.readline().split()))\r\n    for __ in range(Q):\r\n        query = stdin.readline().split()\r\n        if query[0] == \"A\":\r\n            i, v = map(int, query[1:])\r\n            prices[i - 1] = v\r\n        elif query[0] == \"P\":\r\n            i, j = map(int, query[1:])\r\n            stdout.write(f\"{sum(prices[i - 1:j])}\\n\")\n```"
    }
  },
  {
    "id": "1025",
    "name": "Habilidad Mental",
    "extension": "py",
    "filename": "1025_Habilidad_Mental.py",
    "path": "1000-1199/1025_Habilidad_Mental.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1025",
    "tags": [
      "facil",
      "hashmap",
      "matematicas",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "Para este ejercicio se hace uso del concepto de distancia\r\n entre puntos en un plano cartesiano.\r\n\r\n $$\r\n d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\r\n $$\r\n\r\n > [!note] Nota\r\n > En el código se utiliza el valor `min_distance = maxsize` para\r\n > inicializar la variable que guardará la distancia minima,\r\n > inicialmente es el valor máximo posible para que puede ser\r\n > reemplazado por cualquier valor menor.",
      "steps": "1. Recibir la cantidad de puntos `N` en la pantalla\r\n 2. Recibir `N` lineas de entrada, donde cada linea tiene los valores `x` `y` `color`\r\n 3. Castear los valores `x` y `y` a enteros y el color a string\r\n 4. Guardar los valores en un diccionario, donde la clave es el color y el valor es una lista de tuplas con las coordenadas\r\n 5. Ordenar el diccionario por clave\r\n 6. Iterar sobre el diccionario\r\n 7. Por cada color, calcular la distancia minima entre la lista de coordenadas\r\n 8. Imprimir el color y la distancia minima",
      "code": "```python\nfrom sys import maxsize\r\n\r\n\r\ndef get_distance(coord_1: tuple[int], coord_2: tuple[int]):\r\n    x1, y1 = coord_1\r\n    x2, y2 = coord_2\r\n    return pow(pow(x2 - x1, 2) + pow(y2 - y1, 2), 0.5)\r\n\r\n\r\ndef min_distance(values: list[int]):\r\n    # Maximo valor posible en un sistema de 64 bits\r\n    min_distance = maxsize\r\n    for i in range(len(values)):\r\n        for j in range(i + 1, len(values)):\r\n            distance = get_distance(values[i], values[j])\r\n            if distance < min_distance:\r\n                min_distance = distance\r\n    return min_distance\r\n\r\n\r\nN = int(input())\r\nvalues = dict()\r\n\r\nfor i in range(N):\r\n    params = input().split()\r\n    coords = tuple(map(int, params[:2]))\r\n    color = params[2]\r\n\r\n    if color not in values:\r\n        values[color] = [coords]\r\n        continue\r\n    values[color].append(coords)\r\n\r\nvalues = dict(sorted(values.items()))\r\nfor key, value in values.items():\r\n    print(f\"{key} {min_distance(value):.2f}\")\n```"
    }
  },
  {
    "id": "1026",
    "name": "Tuncuna",
    "extension": "py",
    "filename": "1026_Tuncuna.py",
    "path": "1000-1199/1026_Tuncuna.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1026",
    "tags": [
      "facil",
      "matematicas",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "> [!note] Sobre el input y print\r\n > La solución hace uso del modulo `sys` para leer y escribir datos por\r\n > temas de problemas con el juez patito, ya que las funciones `input()`\r\n > y `print()` no funcionan correctamente con este problema.",
      "steps": "1. Recibir la cantidad de veces `T` que juega Bob\r\n 2. Por cada jugada, recibir un entero `N` que representa la casilla a la que quiere llegar\r\n 3. Seguir la serie sumando 1, 2, 3, ... hasta llegar a la casilla `N`\r\n 4. Si la suma da igual a `N`, entonces mostrar \"Go On Bob\" y la cantidad de pasos que se necesita, de lo contrario mostrar el el mensaje \"Better Luck Next Time\"",
      "code": "```python\nfrom sys import stdin, stdout\r\n\r\nT = int(stdin.readline())\r\nfor i in range(1, T + 1, 1):\r\n    N = int(stdin.readline())\r\n    n = int(pow(0.25 + 2 * N, 0.5) - 0.5)\r\n    sum = n * (n + 1) // 2\r\n    if sum == N:\r\n        stdout.write(\"Go On Bob \" + str(n) + \"\\n\")\r\n    else:\r\n        stdout.write(\"Better Luck Next Time\" + \"\\n\")\n```"
    }
  },
  {
    "id": "1027",
    "name": "INFIX",
    "extension": "py",
    "filename": "1027_INFIX.py",
    "path": "1000-1199/1027_INFIX.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1027",
    "tags": [
      "medio",
      "matematicas",
      "colas",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "> [!note] Operaciones\r\n > Para este caso se representa los operadores como:\r\n > - `S` para la suma `+`\r\n > - `R` para la resta `-`\r\n > - `M` para la multiplicación `*`\r\n > - `D` para la división `/`\r\n > - `C` para elevar al cuadrado `**2`\r\n\r\n Para este problema es necesario tomar en cuenta ciertas condiciones:\r\n\r\n - Si solo hay un número, se imprime el mismo número\r\n - Si hay más de un operador, se define el resultado del primero con el segundo y así sucesivamente\r\n - Si el numero es menor a 1, se utiliza el siguiente digito (0.9 -> 9)\r\n\r\n Para la tercera condición puede parecer confuso, pero como tal es algo necesario\r\n para que pueda ser aceptado por el juez en línea. Sin embargo, el proceso para que\r\n sea aceptado está comentado en el código porque no tiene lógica y uso más que para\r\n el juez en línea.",
      "steps": "1. Recibir el número de casos de prueba `T`\r\n 2. Por cada caso, recibir la siguiente sucesión formada por:\r\n     - numeros enteros\r\n     - operadores aritméticos\r\n 3. Mostrar el resultado de la operación aritmética",
      "code": "```python\n# funciones lambda para las operaciones\r\noperators = {\r\n    \"S\": lambda x, y: x + y,\r\n    \"R\": lambda x, y: x - y,\r\n    \"M\": lambda x, y: x * y,\r\n    \"D\": lambda x, y: x / y,\r\n    \"C\": lambda x: x**2,\r\n}\r\n\r\nT = int(input())\r\nfor i in range(T):\r\n    line = list(input().split())\r\n    queue = []\r\n    for item in line:\r\n        if item not in operators:\r\n            queue.append(int(item))\r\n            continue\r\n\r\n        if item == \"C\":\r\n            element = queue.pop()\r\n            # result = operators[item](element)\r\n            # queue.append(round(result * 10 ,0) if result < 1 else result)\r\n            queue.append(operators[item](element))\r\n        else:\r\n            element1 = queue.pop()\r\n            element2 = queue.pop()\r\n            # result = operators[item](element2, element1)\r\n            # queue.append(round(result * 10 ,0) if result < 1 else result)\r\n            queue.append(operators[item](element2, element1))\r\n\r\n    print(int(queue[0]))\n```"
    }
  },
  {
    "id": "1029",
    "name": "Escoger Equipos",
    "extension": "py",
    "filename": "1029_Escoger_Equipos.py",
    "path": "1000-1199/1029_Escoger_Equipos.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1029",
    "tags": [
      "facil",
      "listas",
      "matematicas",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "El problema nos dara una lista de números que representa la capacidad de jugadores de algún juego, la idea es formar **dos equipos** tomando por capitanes a los dos jugadores con mayor capacidad, luego **se alternara la elección de jugadores entre los dos capitanes**, esto se resuelve utilizando una *bandera* para saber a que equipo le toca elegir.",
      "steps": "1. Recibir datos indeterminadamente hasta que no haya más datos, es decir hasta que se presione enter.\r\n 2. Ordenar la lista de jugadores de mayor a menor.\r\n 3. Crear dos variables para almacenar la suma de las capacidades de los jugadores de cada equipo.\r\n 4. Crear una variable booleana para alternar la elección de jugadores entre los dos equipos.\r\n 5. Iterar sobre la lista de jugadores y sumar la capacidad de los jugadores a los equipos.\r\n 6. Imprimir la diferencia de las capacidades de los equipos.",
      "code": "```python\nfrom sys import stdin\r\n\r\nfor line in stdin:\r\n    if line == \"\\n\":\r\n        break\r\n\r\n    players = list(map(int, line.split()))\r\n    # Se puede usar sort() o algun metodo de ordenamiento como el burbuja o seleccion\r\n    players.sort(reverse=True)\r\n\r\n    swap = False\r\n    sum_1 = sum_2 = 0\r\n    for player in players:\r\n        if swap:\r\n            sum_1 += player\r\n        else:\r\n            sum_2 += player\r\n\r\n        swap = not swap\r\n\r\n    result = abs(sum_1 - sum_2)\r\n    print(result)\n```"
    }
  },
  {
    "id": "1030",
    "name": "Collares",
    "extension": "py",
    "filename": "1030_Collares.py",
    "path": "1000-1199/1030_Collares.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1030",
    "tags": [
      "strings",
      "bucles"
    ],
    "content": {
      "description": "TODO: Revisar la descripcion del problema",
      "steps": "",
      "code": "```python\nfrom sys import stdin\r\n\r\nfor line in stdin:\r\n    if line == \"\\n\":\r\n        break\r\n\r\n    # ordenar la cadena alfabeticamente\r\n    line = sorted(line.strip())\r\n    print(line)\n```"
    }
  },
  {
    "id": "1031",
    "name": "Mediana",
    "extension": "py",
    "filename": "1031_Mediana.py",
    "path": "1000-1199/1031_Mediana.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1031",
    "tags": [
      "matematicas",
      "facil",
      "ordenamiento",
      "listas",
      "bucles",
      "condicionales"
    ],
    "content": {
      "description": "La lógica de este problema es obtener la *mediana* de una lista de números dados, inicialmente\r\n las condiciones que se toman en cuenta son:\r\n\r\n - La lista de números es de tamaño impar.\r\n - La lista de números está ordenada.\r\n\r\n Si se cumple con esto, entonces pasamos a obtener la mediana de la lista con la siguiente fórmula:\r\n\r\n $$\r\n M = \\\\frac{n}{2}\r\n $$\r\n\r\n Donde `M` es `median_index` (la posición de la mediana en la lista). Por otro lado, la otra condición es que tanto a la izquierda como a la derecha de la mediana no existan números iguales a la mediana, si se cumple esta condición, entonces la mediana es correcta, de lo contrario, la mediana no es correcta.",
      "steps": "1. Recibir casos de prueba hasta que se reciba una línea en blanco `\\n`.\r\n 2. Por cada caso, recibir la cantidad de números `n`, seguido de la lista de números.\r\n 3. Ordenar la lista de números.\r\n 4. Si `n` es par, imprimir `-1` y continuar con el siguiente caso.\r\n 5. Calcular la posición de la mediana `median_index = (n) // 2`.\r\n 6. Inicializar dos variables `i` y `j` con los valores `median_index - 1` y `median_index + 1` respectivamente.\r\n 7. Inicializar una variable `is_median` en `True` para saber si la mediana es correcta.\r\n 8. Recorrer la lista de números hacia la izquierda y derecha desde la posición de la mediana para verificar si la mediana es correcta.\r\n 9. Si la mediana es correcta, imprimir el valor de la mediana, de lo contrario imprimir `-1`.",
      "code": "```python\nfrom sys import stdin\r\n\r\n\r\nfor line in stdin:\r\n    if line == \"\\n\":\r\n        break\r\n\r\n    n = int(line)\r\n    numbers = list(map(int, input().split()))\r\n    numbers.sort()\r\n\r\n    if n % 2 == 0:\r\n        print(-1)\r\n        continue\r\n\r\n    median_index = (n) // 2\r\n    i, j = median_index - 1, median_index + 1\r\n    is_median = True\r\n    while i >= 0 and j < n:\r\n        if numbers[i] == numbers[median_index]:\r\n            is_median = False\r\n            break\r\n        if numbers[j] == numbers[median_index]:\r\n            is_median = False\r\n            break\r\n        i -= 1\r\n        j += 1\r\n\r\n    if is_median:\r\n        print(numbers[median_index])\r\n    else:\r\n        print(-1)\n```"
    }
  },
  {
    "id": "1032",
    "name": "Unica Aparicion",
    "extension": "py",
    "filename": "1032_Unica_Aparicion.py",
    "path": "1000-1199/1032_Unica_Aparicion.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1032",
    "tags": [
      "medio",
      "listas",
      "operadores-binarios",
      "bucles"
    ],
    "content": {
      "description": "El problema se basa en que tenemos una lista de números donde existen pares de ellos, es decir\r\n que se repiten dos veces, excepto uno que se repite una sola vez. Debemos encontrar ese número.\r\n\r\n La forma más sencilla de hacerlo es mediante **el operador XOR**, que se basa en la siguiente tabla:\r\n\r\n | A | B | A XOR B |\r\n |---|---|---------|\r\n | 0 | 0 |   0     |\r\n | 0 | 1 |   1     |\r\n | 1 | 0 |   1     |\r\n | 1 | 1 |   0     |\r\n\r\n Es decir, si A y B son iguales, entonces el resultado es 0, de lo contrario es 1. Por lo tanto, aplicando esto a números es casi lo mismo, utilizaremos la propiedad:\r\n\r\n $$\r\n A \\oplus 0 = A\r\n $$\r\n\r\n Que nos dice que **si un número se compara con 0, el resultado es el mismo número**. Por lo tanto, si tenemos una lista de números y los comparamos con el operador XOR, los números que se repiten dos veces se cancelarán y el único número que se repite una vez quedará.\r\n\r\n $$\r\n A_1 \\oplus A_2 \\oplus A_3 \\oplus \\ldots \\oplus A_n) = A_{\\text{único}}\r\n $$\r\n\r\n > [!IMPORTANT]\r\n > Para este problema, se utiliza el módulo `sys` con las funciones `stdin` y `stdout` para leer y escribir datos, respectivamente. Esto se hace para mejorar la eficiencia del programa, ya que la función `input()` y `print()` son más lentas lo que causa un error en el juez.",
      "steps": "1. Leer el número de elementos de la lista.\r\n 2. Inicializar una variable `result` en 0.\r\n 3. Iterar sobre la lista de números.\r\n 4. Por cada número, aplicar el operador XOR con la variable `result`.\r\n 5. Al finalizar, imprimir el valor de `result`.",
      "code": "```python\nfrom sys import stdin, stdout\r\n\r\nn = int(stdin.readline())\r\nresult = 0\r\nfor x_i in range(n):\r\n    result ^= int(stdin.readline())\r\nstdout.write(f\"{result}\\n\")\n```"
    }
  },
  {
    "id": "1033",
    "name": "Contando Primos",
    "extension": "py",
    "filename": "1033_Contando_Primos.py",
    "path": "1000-1199/1033_Contando_Primos.py",
    "url": "https://jv.umsa.bo/oj/problem.php?id=1033",
    "tags": [
      "facil",
      "matematicas"
    ],
    "content": {
      "description": "",
      "steps": "",
      "code": "```python\n\n```"
    }
  }
]